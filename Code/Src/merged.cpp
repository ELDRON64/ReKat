#define OPENGL
#define ONLINE_PEER
#include <ReKat.hpp>
using namespace ReKat;
#include <Graphik/shader.h>

#include <sstream>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <filesystem>

bool Main_shutdown = false;
std::string msg_stream;

int current_command = 0;
std::vector < std::string > history;

std::stringstream output;

int start_line = 0;
int total_lines = 0;

int generate_id ( size_t hash ) {
    int D = time (0);
    std::hash <size_t> hasher;
    return hasher( hash + hasher (D) );
}

// file saved for every user/password
// root:
//      <client_hash>:
//          main_client_log.data   // the main log // saves identifier and concected_cleints names and IDs, // crivpted with key generated by name_pasw_hash 
//          <conected_client1_log> // a log for eatch connected socket (identified by their name and identifier)
//          <conected_client2_log>
//          <conected_client3_log>
enum Status {
    SUCCES,
    PATH_EXISTS
};

std::string setup ( size_t path_hash ) {
    std::string path = std::to_string ( path_hash );

    if ( std::filesystem::exists ( path ) ) { return path; }

    std::filesystem::create_directory ( path );

    return path;
}

enum COMMAND_STATUS {
    SUCCESS,
    NO_COMMAND = -1,
    FAULTY_COMMAND = -2,
    INCORRECT_COMMAND = -3,
    TERMINATE = -999
};

void Connections ( ) { 
    while ( !Main_shutdown ) { 
        online::New_Connection();
    output << "Connected to: " << online::Connected()[online::Connected().size()-1] <<'\n';
} }

void Recive ( std::string node ) {
    char *_buf; int status;
    while ( !Main_shutdown ) {
        // constanly read 
        _buf = (char*) calloc ( BUF_LEN + 1, sizeof(char) ); 
        status = online::Recv ( _buf, BUF_LEN, node, -1 );
        output << "message from " + node + ": " + std::string(_buf) + '\n';
        if ( status == online::FAILED_RECV ) { return; }
    }
}

void Check_connections ( std::string out_path ) {
    std::vector < std::thread > node_threads;
    std::vector < std::string > nodes = online::Connected();
    std::string node_name;
    while ( !Main_shutdown ) {
        if ( nodes == online::Connected() ) { continue; }
        nodes = online::Connected();
        // inizialize last n
        int N = nodes.size() - node_threads.size();
        for (int i = 0; i < N; i++) {
            node_name = nodes[nodes.size() - i - 1];
            node_threads.push_back ( std::thread ( Recive, node_name ) );
        }
    }

    // terminate nodes
    if ( node_threads.size() == 0 ) { return; }
    for ( size_t i = 0; i < node_threads.size() - 1; i++ ) { TerminateThread ( node_threads[i].native_handle(), 1 ); node_threads[i].detach(); }

    output << "local nodes terminated\n";
}

long long command ( std::string command ) {
    // tokenize
    // Vector of string to save tokens
    std::vector <std::string> tokens;
     
    // stringstream class check1
    std::stringstream check1(command);
    
    std::string intermediate;
     
    // Tokenizing w.r.t. space ' '
    while ( getline ( check1, intermediate, ' ' ) ) { tokens.push_back(intermediate); }

    // command set ---------------------
    // ---------------------------------
    if ( tokens.size( ) == 1 ) { return NO_COMMAND; }

    tokens.erase ( tokens.begin () );


    // args: name, ip, <port>
    if ( tokens[0] == "connect" ) {
        if ( tokens.size ( ) == 3 ) { return online::Connect ( tokens[1], tokens[2] ); }
        if ( tokens.size ( ) == 4 ) { return online::Connect ( tokens[1], tokens[2], tokens[3].c_str( ) ); }
        return FAULTY_COMMAND;
    }

    // args: node, msg
    if ( tokens[0] == "msg" ) {
        if ( tokens.size ( ) == 3 ) { return online::Send ( tokens[2].c_str(), tokens[2].size(), tokens[1] ); }
        return FAULTY_COMMAND;
    }

    if ( tokens[0] == "connected" ) {
        for( auto s : online::Connected () ) { output << "connected to: " << s << '\n'; } return SUCCESS;
    }

    if ( tokens[0] == "get" ) {
        output << msg_stream;
        msg_stream = "";
        return SUCCESS;
    }

    if ( tokens[0] == "clear" ) { output.str(""); output << "ReKat\n"; return SUCCESS; }

    return INCORRECT_COMMAND;
}

void execute_command ( ) {
    if (history[current_command] == "$ exit") { Main_shutdown = true; grapik::End(); }
    int r = command ( history[current_command] );
    if ( r != 0 ) {
        output << "command error: ";
        switch ( r ) {
            case -1: output << "NO_COMMAND\n"; break;
            case -2: output << "FAULTY_COMMAND\n"; break;
            case -3: output << "INCORRECT_COMMAND\n"; break;
        }
    }
    current_command = history.size ( ); 
    history.push_back ("$ ");
}

bool ctrl = false;
bool shift = false;

static void grapik::Input::Keyboard ( GLFWwindow* window, int key, int scancode, int action, int mode ) {
    if ( key == GLFW_KEY_ESCAPE ) { grapik::End(); }

    // shift
    if ( key == GLFW_KEY_LEFT_SHIFT || key == GLFW_KEY_RIGHT_SHIFT ) {
        if ( action == GLFW_PRESS ) { shift = true; } 
        else { shift = false; }
    }
    // ctrl
    if ( key == GLFW_KEY_LEFT_CONTROL || key == GLFW_KEY_RIGHT_CONTROL ) {
        if ( action == GLFW_PRESS ) { ctrl = true; } 
        else { ctrl = false; }
    }

    if ( ( action == GLFW_PRESS || action == GLFW_REPEAT ) ) {
        if ( key == GLFW_KEY_ESCAPE ) { grapik::End(); }
        if ( key == GLFW_KEY_ENTER ) { execute_command ();  return; }
        if ( key == GLFW_KEY_DELETE || key == GLFW_KEY_BACKSPACE ) 
        { if ( history[current_command].size() > 2 ) { history[current_command].pop_back (); } return; }
        if ( key == GLFW_KEY_DOWN ) 
        { if ( current_command < history.size( ) - 1 ) { current_command ++; } return; }
        if ( key == GLFW_KEY_UP ) 
        { if ( current_command > 0) { current_command --; }  return; }
    }
}
static void grapik::Input::Mouse ( GLFWwindow* window, double xpos, double ypos ) { }
static void grapik::Input::ScrollWell ( GLFWwindow* window, double xoffset, double yoffset ) {
    if ( yoffset >= 0 ) { start_line ++; }
    if ( yoffset <= 0 ) { start_line --; }
}
static void grapik::Input::FreamBufferResize ( GLFWwindow* window, int width, int height ) { }
static void grapik::Input::Caracters ( GLFWwindow* window, unsigned int codepoint ) {
    history[current_command] += (char)(codepoint);
}

/// Holds all state information relevant to a character as loaded using FreeType
struct Character {
    unsigned int TextureID; // ID handle of the glyph texture
    glm::ivec2   Size;      // Size of glyph
    glm::ivec2   Bearing;   // Offset from baseline to left/top of glyph
    unsigned int Advance;   // Horizontal offset to advance to next glyph
};

std::map<GLchar, Character> Characters;
unsigned int VAO, VBO;

const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

int RenderText(Shader &shader, std::string text, float init_x, float init_y, float scale, glm::vec3 color, float to_wrap, float wrap_h, int Max_Rows, int Start_Row )
{
    // activate corresponding render state	
    shader.use();
    glUniform3f(glGetUniformLocation(shader.ID, "textColor"), color.x, color.y, color.z);
    glActiveTexture(GL_TEXTURE0);
    glBindVertexArray(VAO);

    // iterate through all characters
    std::string::const_iterator c;
    int x = init_x, y = init_y;

    y -= (scale * wrap_h ) * Start_Row;
    int last_y = init_y - (scale * wrap_h ) * Max_Rows;
    int Rows = 0;
 
    for (c = text.begin(); c != text.end(); c++) {
        // new line check
        if ( *c == '\n' ) { y -= (scale * wrap_h ); Rows++; x = init_x; continue; }
        // last line chiek
        if ( ! ( y <= last_y ) ) { 
            Character ch = Characters[*c];

            float xpos = x + ch.Bearing.x * scale;
            float ypos = y - (ch.Size.y - ch.Bearing.y) * scale;

            float w = ch.Size.x * scale;
            float h = ch.Size.y * scale;
            // update VBO for each character
            float vertices[6][4] = {
                { xpos,     ypos + h,   0.0f, 0.0f },            
                { xpos,     ypos,       0.0f, 1.0f },
                { xpos + w, ypos,       1.0f, 1.0f },

                { xpos,     ypos + h,   0.0f, 0.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos + w, ypos + h,   1.0f, 0.0f }           
            };
            // render glyph texture over quad
            glBindTexture(GL_TEXTURE_2D, ch.TextureID);
            // update content of VBO memory
            glBindBuffer(GL_ARRAY_BUFFER, VBO);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); // be sure to use glBufferSubData and not glBufferData

            glBindBuffer(GL_ARRAY_BUFFER, 0);
            // render quad
            glDrawArrays(GL_TRIANGLES, 0, 6);
            // now advance cursors for next glyph (note that advance is number of 1/64 pixels)
            x += (ch.Advance >> 6) * scale; // bitshift by 6 to get value in pixels (2^6 = 64 (divide amount of 1/64th pixels by 64 to get amount of pixels))
        }

        // text wrapping
        if ( x >= ( to_wrap + init_x ) ) { y -= (scale * wrap_h ); Rows++; x = init_x; }
    }
    glBindVertexArray(0);
    glBindTexture(GL_TEXTURE_2D, 0);
    return Rows;
}

int main(int argc, char const *argv[]) {
    std::string name = "giovanni";
    std::string pass = "Gattone";
    int port;
    std::cout << "port: "; std::cin >> port;
    output << "ReKat\n";
    
    long long start_result = online::Start ( name, 0, port ) << '\n';
    output << "start result: " << ( start_result == 0 ? "succes" : "failed: " + std::to_string ( start_result ) ) << '\n';
    
    std::hash <std::string> hasher;
    size_t path_hash      = hasher ( name + pass );
    size_t generator_hash = hasher ( name + "_" + pass );
    size_t id = generate_id ( path_hash );
    std::string path = setup ( path_hash + id );
    output << "setup path: " << path << '\n';
    output << "id: " << id << '\n';

    // start new_conection node
    std::thread conn_thread;
    conn_thread = std::thread ( Connections );

    std::thread recv_thread;
    recv_thread = std::thread ( Check_connections, path );

    grapik::Start ( "ReKat Kave", SCR_WIDTH, SCR_HEIGHT );

    Shader shader("Shaders/text.vs", "Shaders/text.fs");
    glm::mat4 projection = glm::ortho(0.0f, static_cast<float>(SCR_WIDTH), 0.0f, static_cast<float>(SCR_HEIGHT));
    shader.use();
    glUniformMatrix4fv(glGetUniformLocation(shader.ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));

    // FreeType
    // --------
    FT_Library ft;
    // All functions return a value different than 0 whenever an error occurred
    if (FT_Init_FreeType(&ft))
    {
        output << "ERROR::FREETYPE: Could not init FreeType Library" << std::endl;
        return -1;
    }

	// find path to font
    std::string font_name = "Antonio-Bold.ttf";
    if (font_name.empty())
    {
        output << "ERROR::FREETYPE: Failed to load font_name" << std::endl;
        return -1;
    }
	
	// load font as face
    FT_Face face;
    if (FT_New_Face(ft, font_name.c_str(), 0, &face)) {
        output << "ERROR::FREETYPE: Failed to load font" << std::endl;
        return -1;
    }
    else {
        // set size to load glyphs as
        FT_Set_Pixel_Sizes(face, 0, 48);

        // disable byte-alignment restriction
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

        // load first 128 characters of ASCII set
        for (unsigned char c = 0; c < 128; c++)
        {
            // Load character glyph 
            if (FT_Load_Char(face, c, FT_LOAD_RENDER))
            {
                output << "ERROR::FREETYTPE: Failed to load Glyph" << std::endl;
                continue;
            }
            // generate texture
            unsigned int texture;
            glGenTextures(1, &texture);
            glBindTexture(GL_TEXTURE_2D, texture);
            glTexImage2D(
                GL_TEXTURE_2D,
                0,
                GL_RED,
                face->glyph->bitmap.width,
                face->glyph->bitmap.rows,
                0,
                GL_RED,
                GL_UNSIGNED_BYTE,
                face->glyph->bitmap.buffer
            );
            // set texture options
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            // now store character for later use
            Character character = {
                texture,
                glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),
                glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),
                static_cast<unsigned int>(face->glyph->advance.x)
            };
            Characters.insert(std::pair<char, Character>(c, character));
        }
        glBindTexture(GL_TEXTURE_2D, 0);
    }
    // destroy FreeType once we're finished
    FT_Done_Face(face);
    FT_Done_FreeType(ft);

    
    // configure VAO/VBO for texture quads
    // -----------------------------------
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    history.push_back ("$ ");

    // main loop
    while ( !Main_shutdown && grapik::IsEnd( ) ) {
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // command out;
        total_lines = total_lines <= 8 ? 0 : total_lines - 8;
        total_lines  = RenderText ( shader, output.str(), 25.0f, SCR_HEIGHT - 75.0f, 1.0f, glm::vec3(0.5, 0.8f, 0.2f), SCR_WIDTH - 50.0f, 50.0f, 8, start_line - total_lines );

        // command box
        RenderText ( shader, history[current_command], 25.0f, 100.0f, 0.75f, glm::vec3(0.3, 0.7f, 0.9f),SCR_WIDTH - 50.0f, 50.0f, 3, 0 );

        grapik::Pool();
    }

    Main_shutdown = true;

    // terminate threads
    try { 
        recv_thread.join ( );
        TerminateThread (conn_thread.native_handle(),1);
        conn_thread.detach ( );
    } catch ( const std::exception& e ) { std::cerr << e.what() << '\n'; }
    
    grapik::Terminate ( ); 
    
    output << "correctly ended\n";
    return SUCCESS;
}
