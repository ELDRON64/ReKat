#define ONLINE_PEER
#include <ReKat.hpp>
using namespace ReKat;

#include <sstream>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <filesystem>

bool Main_shutdown = false;
std::string msg_stream;

int generate_id ( size_t hash ) {
    int D = time (0);
    std::hash <size_t> hasher;
    return hasher( hash + hasher (D) );
}

// file saved for every user/password
// root:
//      <client_hash>:
//          main_client_log.data   // the main log // saves identifier and concected_cleints names and IDs, // crivpted with key generated by name_pasw_hash 
//          <conected_client1_log> // a log for eatch connected socket (identified by their name and identifier)
//          <conected_client2_log>
//          <conected_client3_log>
enum Status {
    SUCCES,
    PATH_EXISTS
};

std::string setup ( size_t path_hash ) {
    std::string path = std::to_string ( path_hash );

    if ( std::filesystem::exists ( path ) ) { return path; }

    std::filesystem::create_directory ( path );

    return path;
}

enum COMMAND_STATUS {
    SUCCESS,
    NO_COMMAND = -1,
    FAULTY_COMMAND = -2,
    INCORRECT_COMMAND = -3,
    TERMINATE = -999
};

void Connections ( std::ofstream *_out ) { *_out << "Getting connections\n"; while ( !Main_shutdown ) { 
    *_out << "New_connection result: " << online::New_Connection () << '\n'; 
    for ( auto p : online::Connected() ) { *_out << "Connected to: " << p <<'\n'; }
} }

void Recive ( std::string node ) {
    char *_buf; int status;
    while ( !Main_shutdown ) {
        // constanly read 
        _buf = (char*) calloc ( BUF_LEN + 1, sizeof(char) ); 
        status = online::Recv ( _buf, BUF_LEN, node, -1 );
        msg_stream += "message from " + node + ": " + std::string(_buf) + '\n';
        if ( status == online::FAILED_RECV ) { return; }
    }
}

void Check_connections ( std::string out_path ) {
    std::vector < std::thread > node_threads;
    std::vector < std::string > nodes = online::Connected();
    std::string node_name;
    while ( !Main_shutdown ) {
        if ( nodes == online::Connected() ) { continue; }
        nodes = online::Connected();
        // inizialize last n
        int N = nodes.size() - node_threads.size();
        for (int i = 0; i < N; i++) {
            node_name = nodes[nodes.size() - i - 1];
            node_threads.push_back ( std::thread ( Recive, node_name ) );
        }
    }

    // terminate nodes
    if ( node_threads.size() == 0 ) { return; }
    for ( size_t i = 0; i < node_threads.size() - 1; i++ ) { TerminateThread ( node_threads[i].native_handle(), 1 ); }

    std::cout << "local nodes terminated\n";
}

long long command ( std::string command ) {
    // tokenize
    // Vector of string to save tokens
    std::vector <std::string> tokens;
     
    // stringstream class check1
    std::stringstream check1(command);
    
    std::string intermediate;
     
    // Tokenizing w.r.t. space ' '
    while ( getline ( check1, intermediate, ' ' ) ) { tokens.push_back(intermediate); }

    // command set ---------------------
    // ---------------------------------
    if ( tokens.size( ) == 0 ) { return NO_COMMAND; }

    // args: name, ip, <port>
    if ( tokens[0] == "connect" ) {
        if ( tokens.size ( ) == 3 ) { return online::Connect ( tokens[1], tokens[2] ); }
        if ( tokens.size ( ) == 4 ) { return online::Connect ( tokens[1], tokens[2], tokens[3].c_str( ) ); }
    }

    // args: node, msg
    if ( tokens[0] == "msg" ) {
        if ( tokens.size ( ) == 3 ) { return online::Send ( tokens[2].c_str(), tokens[2].size(), tokens[1] ); }
    }

    if ( tokens[0] == "connected" ) {
        for( auto s : online::Connected () ) { std::cout << "connected to: " << s << '\n'; } return SUCCESS;
    }

    if ( tokens[0] == "get") {
        std::cout << msg_stream;
        msg_stream = "";
        return SUCCESS;
    }

    std::cout << "\n" << command << " is incorrect\n";
    return INCORRECT_COMMAND;
}

int main(int argc, char const *argv[]) {
    std::string name = "Giovanni";
    std::string pass = "Gattone";
    std::string port;
    std::cout << "port: "; std::cin >> port;
    
    long long start_result = online::Start ( name, port ) << '\n';
    std::cout << "start result: " << ( start_result == 0 ? "succes" : "failed: " + std::to_string ( start_result ) ) << '\n';
    
    std::hash <std::string> hasher;
    size_t path_hash      = hasher ( name + pass );
    size_t generator_hash = hasher ( name + "_" + pass );
    size_t id = generate_id ( path_hash );
    std::string path = setup ( path_hash + id );
    std::cout << "setup path: " << path << '\n';
    std::cout << "id: " << id << '\n';

    // start new_conection node
    std::thread conn_thread;
    std::ofstream conn_stream ( path + "/connections" );
    conn_thread = std::thread ( Connections, &conn_stream );

    std::thread recv_thread;
    recv_thread = std::thread ( Check_connections, path );

    std::string input;
    int r;
    while ( !Main_shutdown ) {
        std::cout << "\n" << name << "$ ";
        std::getline (std::cin, input);
        if (input == "exit") { Main_shutdown = true; break; }
        r = command ( input );
        std::cout << "command result: " << r;
    }

    // terminate threads
    try { 
        recv_thread.join ( );
        TerminateThread (conn_thread.native_handle(),1);
        conn_thread.detach ( );
        conn_stream.close ( );
    } catch ( const std::exception& e ) { std::cerr << e.what() << '\n'; }
    
    std::cout << "correctly ended\n";
    return SUCCESS;
}
