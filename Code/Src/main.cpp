#define ONLINE_PEER 
#include <ReKat.hpp>
using namespace ReKat;

#include <sstream>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>

#include <filesystem>

bool Main_shutdown = false;

int generate_id ( size_t hash ) {
    int D = time (0);
    std::hash <size_t> hasher;
    return hasher( hash + hasher (D) );
}

// file saved for every user/password
// root:
//      <client_hash>:
//          main_client_log.data   // the main log // saves identifier and concected_cleints names and IDs, // crivpted with key generated by name_pasw_hash 
//          <conected_client1_log> // a log for eatch connected socket (identified by their name and identifier)
//          <conected_client2_log>
//          <conected_client3_log>
enum Status {
    SUCCES,
    PATH_EXISTS
};

int setup ( size_t path_hash ) {
    std::string path = std::to_string ( path_hash );

    if ( std::filesystem::exists ( path ) ) { return PATH_EXISTS; }

    std::filesystem::create_directory ( path );

    return SUCCES;
}

enum COMMAND_STATUS {
    SUCCESS,
    NO_COMMAND = -1,
    FAULTY_COMMAND = -2,
    INCORRECT_COMMAND = -3,
    TERMINATE = -999
};

void Connections ( std::string out ) {
    std::ofstream _out( out );
    _out << "New_connection result: " << online::New_Connection () << '\n';
    _out << '\n';
    _out.close();
}

void Recive ( std::string outpath, std::string node ) {
    std::ofstream _out ( outpath + '/' + node );
    char *_buf; int status;
    while ( !Main_shutdown ) {
        // constanly read 
        _buf = (char*) calloc ( BUF_LEN, sizeof(char) ); 
        status = online::Recv ( _buf, BUF_LEN, node );
        _out << "Recv retruned: " << status << '\n';
        _out << "_buf value: " << _buf << '\n';

        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }
    _out << '\n';
    _out.close();
}

long long command ( std::string command ) {
    // tokenize
    // Vector of string to save tokens
    std::vector <std::string> tokens;
     
    // stringstream class check1
    std::stringstream check1(command);
    
    std::string intermediate;
     
    // Tokenizing w.r.t. space ' '
    while ( getline ( check1, intermediate, ' ' ) ) { tokens.push_back(intermediate); }

    // command set ---------------------
    // ---------------------------------
    if ( tokens.size( ) == 0 ) { return NO_COMMAND; }

    // args: name, ip, <port>
    if ( tokens[0] == "connect" ) {
        if ( tokens.size ( ) == 3 ) { return online::Connect ( online::Format_String (tokens[1]), tokens[2] ); }
        if ( tokens.size ( ) == 4 ) { return online::Connect ( online::Format_String (tokens[1]), tokens[2], tokens[3].c_str( ) ); }
    }

    // args: node, msg
    if ( tokens[0] == "msg" ) {
        if ( tokens.size ( ) == 3 ) { return online::Send ( tokens[2].c_str(), tokens[2].size(), online::Format_String(tokens[1]) ); }
    }

    if ( tokens[0] == "connected" ) {
        for( auto s : online::Connected () ) {
            std::cout << "connected to: " << s << '\n'; 
        }
        return SUCCESS;
    }

    std::cout << "\n" << command << " is incorrect\n";
    return INCORRECT_COMMAND;
}

int main(int argc, char const *argv[]) {
    std::string name = "Giovanni";
    std::string pass = "Gattone";
    std::string port;
    std::cout << "port: "; std::cin >> port;
    
    long long start_result = online::Start ( name, port ) << '\n';
    std::cout << "start result: " << ( start_result == 0 ? "succes" : "failed: " + std::to_string ( start_result ) ) << '\n';
    size_t id;
    std::hash <std::string> hasher;
    size_t path_hash      = hasher ( name + pass );
    // size_t generator_hash = hasher ( name + "_" + pass );
    setup ( path_hash );

    // start new_conection node

    // start a recive thread for every new_connection



    if ( port == "42069" ) {
        std::cout << "connection: " << online::New_Connection ( ) << '\n';
        std::cout << "connected to: " << online::Connected ( ) [0] << '\n';
        char* _buf = (char*)calloc(5,sizeof(char));
        online::Recv(_buf,4,"pippo");
        std::cout << "msg recived: " << _buf << '\n';
        online::Send("giov",4,"pippo");
    }

    if ( port == "42068" ) {
        std::cout << "new connection: " << online::Connect ("localhost", "localhost") << '\n';

        online::Send("1234",4,"localhost");
        char* _buf = (char*)calloc(5,sizeof(char));
        online::Recv(_buf,4,"localhost");
        std::cout << "msg recived: " << _buf << '\n';
    }
/*
    std::thread recv_thread;
    std::thread conn_thread;

    // start listening thread
    if ( start_result == 0 ) { 
        recv_thread = std::thread ( Recive, "recive" );
        conn_thread = std::thread ( Connections, "connections" );
    }
    
    std::string input;
    int r;
    while ( !Main_shutdown ) {
        std::cout << "\n" << name << "$ ";
        std::getline (std::cin, input);
        if (input == "exit") { Main_shutdown = true; break; }
        r = command ( input );
        std::cout << "command result: " << r;
    }

    recv_thread.join();
    conn_thread.join();
    online::End ( );
*/
}
